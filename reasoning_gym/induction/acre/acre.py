"""ACRE(Abstract Causal REasoning Beyond Covariation) dataset"""

# Culled and Adapted from https://github.com/WellyZhang/ACRE

import json
from dataclasses import dataclass, field
from random import Random
from typing import Any, Dict, List, Optional

from reasoning_gym.factory import ProceduralDataset, register_dataset

from .blicket import config_control, dist_control, final_parse, serialize
from .const import ALL_CONFIG_SIZE, ATTR_CONFIG_SIZE


# Create blicket questions based on 3 regime(IID, Comp, Sys)
@dataclass
class ACREDatasetConfig:
    """Configuration for ACRE dataset generation"""

    train: int = 1  # The default is 1 for training, otherwise 0 for validation and testing
    regime: List[str] = field(default_factory=lambda: ["IID", "Comp", "Sys"])
    size: int = 10  # Ideally we want the size to be in multiples of 10, Split ratio = 6 : 2 : 2 -> IID : Comp : Sys
    seed: Optional[int] = None

    def validate(self) -> None:
        """Validate configuration parameters"""
        assert self.train in set([0, 1]), "train must be either 0 or 1"
        assert self.size % 10 == 0, "size must be a multiple of 10"


class ACREDataset(ProceduralDataset):

    def __init__(self, config: ACREDatasetConfig):
        super().__init__(config, config.seed, config.size)
        self._questions: List[Dict[str, Any]] = None  # initially None, lazy loading
        self.prompt_template = """You are an expert at inductive reasoning. Generate an output corresponding to the given input.
The output is generated by applying the same rule that maps input to output for the examples provided. Your answer should be a list of element/elements
Examples:
{examples}

Input: {input}
Output:
"""

    @property
    def questions(self) -> List[dict[str, Any]]:
        """Lazy load generators only when first accessed"""
        if self._questions is None:
            self._questions = self._load_questions()
        return self._questions

    def _load_questions(self):
        """
        Generates questions of particular size
        """
        questions = []
        iid_size = int(0.6 * self.config.size)
        comp_size = int(0.2 * self.config.size)
        sys_size = int(0.2 * self.config.size)
        iid_questions = config_control(iid_size, self.config.train, ALL_CONFIG_SIZE, self.config.regime[0])
        comp_questions = config_control(comp_size, self.config.train, ATTR_CONFIG_SIZE, self.config.regime[1])
        sys_questions = dist_control(sys_size, self.config.train, self.config.regime[2])
        questions.extend(iid_questions)
        questions.extend(comp_questions)
        questions.extend(sys_questions)
        final_questions = final_parse(serialized_questions=serialize(questions))
        return final_questions

    def __getitem__(self, idx: int) -> dict:
        """Generate a single induction-based list function dataset"""
        inputs = self.questions
        input = inputs[idx]
        examples = input["examples"]
        question = input["question"]
        return {"examples": examples, "question": question, "metadata": {}}


register_dataset("acre", ACREDataset, ACREDatasetConfig)
